=============================
Logrotate
=============================

-----------------------
1、两种切割模式
-----------------------

^^^^^^^^^^^^^^^^^^^
1.1、传统模式
^^^^^^^^^^^^^^^^^^^

| 1、首先重命名当前进程正在输出的日志文件名称，因为进程是根据 ``inode`` 号来确定往哪个日志文件输出，更改日志文件名称并不会影响inode号，所以这步行为中，进程依旧会往修改了名称的日志文件内输出日志。
| 2、进行新的日志创建，创建新的日志名称和老旧的日志名称一样，但是因为是新建的。所以inode号不一样。此时进程日志还是依旧输出到老的被重命名了的日志文件里面。
| 3、对进程发起信号通知，让其重新写日志，比如nginx为 ``kill -user1 pid`` 让其重载配置文件，实现平滑重启，然后来写入到新建的日志里面。

* nginx可能会对不同location定义不同的日志文件。所以一天的日志会有多个不同的日志文件，因为每滚动一次都会进行kill -user1 pid的信号发送，所以需要配合 ``shardscripts`` 参数，让程序把所有日志都重命名了以后，只发送一次kill信号。

^^^^^^^^^^^^^^^^^^^^^^^
1.2、copytruncate模式
^^^^^^^^^^^^^^^^^^^^^^^

| 1、copy当前日志文件，重命名为新文件，这样进程还是往老的文件写入。
| 2、然后logrotate对老文件进行truncate，对老文件进行清空。这样就完成了一次日志切割。

* 这种日志切割不需要对进程发起重载信号。
* 但有个风险，因为会对日志文件进行copy，如果系统文件巨大，那么系统可用空间会突然暴增。
